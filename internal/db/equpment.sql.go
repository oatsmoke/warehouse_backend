// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: equpment.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEquipment = `-- name: CreateEquipment :one
INSERT INTO equipments (serial_number, profile_id, company_id)
VALUES ($1, $2, $3)
RETURNING id, serial_number, profile_id, deleted_at, company_id
`

type CreateEquipmentParams struct {
	SerialNumber string `db:"serial_number" json:"serial_number"`
	ProfileID    int64  `db:"profile_id" json:"profile_id"`
	CompanyID    int64  `db:"company_id" json:"company_id"`
}

func (q *Queries) CreateEquipment(ctx context.Context, arg *CreateEquipmentParams) (*Equipment, error) {
	row := q.db.QueryRow(ctx, createEquipment, arg.SerialNumber, arg.ProfileID, arg.CompanyID)
	var i Equipment
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.ProfileID,
		&i.DeletedAt,
		&i.CompanyID,
	)
	return &i, err
}

const deleteEquipment = `-- name: DeleteEquipment :execresult
UPDATE equipments
SET deleted_at = now()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeleteEquipment(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteEquipment, id)
}

const listEquipment = `-- name: ListEquipment :many
SELECT e.id,
       e.serial_number,
       e.deleted_at,
       p.id             as profile_id,
       p.title          as profile_title,
       c.id             as category_id,
       c.title          as category_title,
       COUNT(*) OVER () AS total
FROM equipments e
         INNER JOIN profiles p ON p.id = e.profile_id
         INNER JOIN categories c ON c.id = p.category_id
WHERE ($1::bool = true OR e.deleted_at IS NULL)
  AND ($2::text = '' OR (e.serial_number || ' ' || p.title || ' ' || c.title) ILIKE '%' || $2 || '%')
  AND (array_length($3::bigint[], 1) IS NULL OR e.id = ANY ($3))
ORDER BY CASE WHEN $4::text = 'id' AND $5::text = 'asc' THEN e.id::text END,
         CASE WHEN $4 = 'id' AND $5 = 'desc' THEN e.id::text END DESC,
         CASE WHEN $4 = 'serial_number' AND $5 = 'asc' THEN e.serial_number END,
         CASE WHEN $4 = 'serial_number' AND $5 = 'desc' THEN e.serial_number END DESC,
         CASE WHEN $4 = 'profile_title' AND $5 = 'asc' THEN p.title END,
         CASE WHEN $4 = 'profile_title' AND $5 = 'desc' THEN p.title END DESC,
         CASE WHEN $4 = 'category_title' AND $5 = 'asc' THEN c.title END,
         CASE WHEN $4 = 'category_title' AND $5 = 'desc' THEN c.title END DESC
LIMIT $7 OFFSET $6
`

type ListEquipmentParams struct {
	WithDeleted      bool    `db:"with_deleted" json:"with_deleted"`
	Search           string  `db:"search" json:"search"`
	Ids              []int64 `db:"ids" json:"ids"`
	SortColumn       string  `db:"sort_column" json:"sort_column"`
	SortOrder        string  `db:"sort_order" json:"sort_order"`
	PaginationOffset int32   `db:"pagination_offset" json:"pagination_offset"`
	PaginationLimit  int32   `db:"pagination_limit" json:"pagination_limit"`
}

type ListEquipmentRow struct {
	ID            int64              `db:"id" json:"id"`
	SerialNumber  string             `db:"serial_number" json:"serial_number"`
	DeletedAt     pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	ProfileID     int64              `db:"profile_id" json:"profile_id"`
	ProfileTitle  string             `db:"profile_title" json:"profile_title"`
	CategoryID    int64              `db:"category_id" json:"category_id"`
	CategoryTitle string             `db:"category_title" json:"category_title"`
	Total         int64              `db:"total" json:"total"`
}

func (q *Queries) ListEquipment(ctx context.Context, arg *ListEquipmentParams) ([]*ListEquipmentRow, error) {
	rows, err := q.db.Query(ctx, listEquipment,
		arg.WithDeleted,
		arg.Search,
		arg.Ids,
		arg.SortColumn,
		arg.SortOrder,
		arg.PaginationOffset,
		arg.PaginationLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEquipmentRow
	for rows.Next() {
		var i ListEquipmentRow
		if err := rows.Scan(
			&i.ID,
			&i.SerialNumber,
			&i.DeletedAt,
			&i.ProfileID,
			&i.ProfileTitle,
			&i.CategoryID,
			&i.CategoryTitle,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEquipment = `-- name: ReadEquipment :one
SELECT e.id,
       e.serial_number,
       e.deleted_at,
       co.id    as company_id,
       co.title as company_title,
       p.id     as profile_id,
       p.title  as profile_title,
       ca.id    as category_id,
       ca.title as category_title
FROM equipments e
         INNER JOIN companies co on co.id = e.company_id
         INNER JOIN profiles p ON p.id = e.profile_id
         INNER JOIN categories ca ON ca.id = p.category_id
WHERE e.id = $1
`

type ReadEquipmentRow struct {
	ID            int64              `db:"id" json:"id"`
	SerialNumber  string             `db:"serial_number" json:"serial_number"`
	DeletedAt     pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	CompanyID     int64              `db:"company_id" json:"company_id"`
	CompanyTitle  string             `db:"company_title" json:"company_title"`
	ProfileID     int64              `db:"profile_id" json:"profile_id"`
	ProfileTitle  string             `db:"profile_title" json:"profile_title"`
	CategoryID    int64              `db:"category_id" json:"category_id"`
	CategoryTitle string             `db:"category_title" json:"category_title"`
}

func (q *Queries) ReadEquipment(ctx context.Context, id int64) (*ReadEquipmentRow, error) {
	row := q.db.QueryRow(ctx, readEquipment, id)
	var i ReadEquipmentRow
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.DeletedAt,
		&i.CompanyID,
		&i.CompanyTitle,
		&i.ProfileID,
		&i.ProfileTitle,
		&i.CategoryID,
		&i.CategoryTitle,
	)
	return &i, err
}

const restoreEquipment = `-- name: RestoreEquipment :execresult
UPDATE equipments
SET deleted_at = NULL
WHERE id = $1
  AND deleted_at IS NOT NULL
`

func (q *Queries) RestoreEquipment(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, restoreEquipment, id)
}

const updateEquipment = `-- name: UpdateEquipment :execresult
UPDATE equipments
SET company_id    = $1,
    profile_id    = $2,
    serial_number = $3

WHERE id = $4
  AND (company_id != $1 OR
       profile_id != $2 OR
       serial_number != $3)
`

type UpdateEquipmentParams struct {
	CompanyID    int64  `db:"company_id" json:"company_id"`
	ProfileID    int64  `db:"profile_id" json:"profile_id"`
	SerialNumber string `db:"serial_number" json:"serial_number"`
	ID           int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateEquipment(ctx context.Context, arg *UpdateEquipmentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateEquipment,
		arg.CompanyID,
		arg.ProfileID,
		arg.SerialNumber,
		arg.ID,
	)
}
