// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: location.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addToStorage = `-- name: AddToStorage :execresult
INSERT INTO locations (equipment_id,
                       user_id,
                       move_at,
                       move_code)
VALUES ($1,
        $2,
        $3,
        $4)
`

type AddToStorageParams struct {
	EquipmentID int64              `db:"equipment_id" json:"equipment_id"`
	UserID      int64              `db:"user_id" json:"user_id"`
	MoveAt      pgtype.Timestamptz `db:"move_at" json:"move_at"`
	MoveCode    string             `db:"move_code" json:"move_code"`
}

func (q *Queries) AddToStorage(ctx context.Context, arg *AddToStorageParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, addToStorage,
		arg.EquipmentID,
		arg.UserID,
		arg.MoveAt,
		arg.MoveCode,
	)
}

const listEquipmentFromLocation = `-- name: ListEquipmentFromLocation :many
select e.id,
       e.serial_number,
       e.company_title,
       e.profile_title,
       e.category_title,
       e.total
from (SELECT DISTINCT ON (l.equipment_id) eq.id,
                                          eq.serial_number,
                                          co.title         AS company_title,
                                          p.title          AS profile_title,
                                          ca.title         AS category_title,
                                          l.to_department_id,
                                          l.to_employee_id,
                                          l.to_contract_id,
                                          COUNT(*) OVER () AS total
      FROM locations l
               LEFT JOIN equipments eq ON eq.id = l.equipment_id
               LEFT JOIN companies co ON co.id = eq.company_id
               LEFT JOIN profiles p ON p.id = eq.profile_id
               LEFT JOIN categories ca ON ca.id = p.category_id
      WHERE eq.deleted_at IS NULL
      ORDER BY l.equipment_id, l.move_at DESC, l.id DESC) e
WHERE (
    $1::bigint = 0
        AND e.to_department_id IS NULL
        AND e.to_employee_id IS NULL
        AND e.to_contract_id IS NULL
    )
   OR (
    $1::bigint > 0
        AND e.to_department_id = $1
    )
ORDER BY e.profile_title, e.serial_number
`

type ListEquipmentFromLocationRow struct {
	ID            pgtype.Int8 `db:"id" json:"id"`
	SerialNumber  pgtype.Text `db:"serial_number" json:"serial_number"`
	CompanyTitle  pgtype.Text `db:"company_title" json:"company_title"`
	ProfileTitle  pgtype.Text `db:"profile_title" json:"profile_title"`
	CategoryTitle pgtype.Text `db:"category_title" json:"category_title"`
	Total         int64       `db:"total" json:"total"`
}

func (q *Queries) ListEquipmentFromLocation(ctx context.Context, toDepartmentID int64) ([]*ListEquipmentFromLocationRow, error) {
	rows, err := q.db.Query(ctx, listEquipmentFromLocation, toDepartmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEquipmentFromLocationRow
	for rows.Next() {
		var i ListEquipmentFromLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.SerialNumber,
			&i.CompanyTitle,
			&i.ProfileTitle,
			&i.CategoryTitle,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveToLocation = `-- name: MoveToLocation :execresult
INSERT INTO locations (equipment_id,
                       user_id,
                       move_at,
                       move_code,
                       from_department_id,
                       from_employee_id,
                       from_contract_id,
                       to_department_id,
                       to_employee_id,
                       to_contract_id)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10)
`

type MoveToLocationParams struct {
	EquipmentID      int64              `db:"equipment_id" json:"equipment_id"`
	UserID           int64              `db:"user_id" json:"user_id"`
	MoveAt           pgtype.Timestamptz `db:"move_at" json:"move_at"`
	MoveCode         string             `db:"move_code" json:"move_code"`
	FromDepartmentID pgtype.Int8        `db:"from_department_id" json:"from_department_id"`
	FromEmployeeID   pgtype.Int8        `db:"from_employee_id" json:"from_employee_id"`
	FromContractID   pgtype.Int8        `db:"from_contract_id" json:"from_contract_id"`
	ToDepartmentID   pgtype.Int8        `db:"to_department_id" json:"to_department_id"`
	ToEmployeeID     pgtype.Int8        `db:"to_employee_id" json:"to_employee_id"`
	ToContractID     pgtype.Int8        `db:"to_contract_id" json:"to_contract_id"`
}

func (q *Queries) MoveToLocation(ctx context.Context, arg *MoveToLocationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, moveToLocation,
		arg.EquipmentID,
		arg.UserID,
		arg.MoveAt,
		arg.MoveCode,
		arg.FromDepartmentID,
		arg.FromEmployeeID,
		arg.FromContractID,
		arg.ToDepartmentID,
		arg.ToEmployeeID,
		arg.ToContractID,
	)
}
