// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password_hash, email, role, employee_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, password_hash, email, role, enabled, last_login_at, employee_id
`

type CreateUserParams struct {
	Username     string      `db:"username" json:"username"`
	PasswordHash string      `db:"password_hash" json:"password_hash"`
	Email        string      `db:"email" json:"email"`
	Role         int32       `db:"role" json:"role"`
	EmployeeID   pgtype.Int8 `db:"employee_id" json:"employee_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.PasswordHash,
		arg.Email,
		arg.Role,
		arg.EmployeeID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Email,
		&i.Role,
		&i.Enabled,
		&i.LastLoginAt,
		&i.EmployeeID,
	)
	return &i, err
}

const deleteUser = `-- name: DeleteUser :execresult
DELETE
FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteUser, id)
}

const getByUsernameUser = `-- name: GetByUsernameUser :one
SELECT id, username, password_hash, email, role, enabled, last_login_at
FROM users
WHERE username = $1
`

type GetByUsernameUserRow struct {
	ID           int64              `db:"id" json:"id"`
	Username     string             `db:"username" json:"username"`
	PasswordHash string             `db:"password_hash" json:"password_hash"`
	Email        string             `db:"email" json:"email"`
	Role         int32              `db:"role" json:"role"`
	Enabled      bool               `db:"enabled" json:"enabled"`
	LastLoginAt  pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
}

func (q *Queries) GetByUsernameUser(ctx context.Context, id string) (*GetByUsernameUserRow, error) {
	row := q.db.QueryRow(ctx, getByUsernameUser, id)
	var i GetByUsernameUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Email,
		&i.Role,
		&i.Enabled,
		&i.LastLoginAt,
	)
	return &i, err
}

const getPasswordHashUser = `-- name: GetPasswordHashUser :one
SELECT password_hash
FROM users
WHERE id = $1
`

func (q *Queries) GetPasswordHashUser(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getPasswordHashUser, id)
	var password_hash string
	err := row.Scan(&password_hash)
	return password_hash, err
}

const listUser = `-- name: ListUser :many
SELECT u.id,
       u.username,
       u.email,
       u.role,
       u.enabled,
       u.last_login_at,
       e.id          as employee_id,
       e.last_name   as employee_last_name,
       e.first_name  as employee_first_name,
       e.middle_name as employee_middle_name,
       e.phone       as employee_phone,
       d.id          as department_id,
       d.title       as department_title
FROM users u
         LEFT JOIN employees e ON e.id = u.employee_id
         LEFT JOIN departments d on d.id = e.department_id
ORDER BY u.id
`

type ListUserRow struct {
	ID                 int64              `db:"id" json:"id"`
	Username           string             `db:"username" json:"username"`
	Email              string             `db:"email" json:"email"`
	Role               int32              `db:"role" json:"role"`
	Enabled            bool               `db:"enabled" json:"enabled"`
	LastLoginAt        pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
	EmployeeID         pgtype.Int8        `db:"employee_id" json:"employee_id"`
	EmployeeLastName   pgtype.Text        `db:"employee_last_name" json:"employee_last_name"`
	EmployeeFirstName  pgtype.Text        `db:"employee_first_name" json:"employee_first_name"`
	EmployeeMiddleName pgtype.Text        `db:"employee_middle_name" json:"employee_middle_name"`
	EmployeePhone      pgtype.Text        `db:"employee_phone" json:"employee_phone"`
	DepartmentID       pgtype.Int8        `db:"department_id" json:"department_id"`
	DepartmentTitle    pgtype.Text        `db:"department_title" json:"department_title"`
}

func (q *Queries) ListUser(ctx context.Context) ([]*ListUserRow, error) {
	rows, err := q.db.Query(ctx, listUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUserRow
	for rows.Next() {
		var i ListUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.Enabled,
			&i.LastLoginAt,
			&i.EmployeeID,
			&i.EmployeeLastName,
			&i.EmployeeFirstName,
			&i.EmployeeMiddleName,
			&i.EmployeePhone,
			&i.DepartmentID,
			&i.DepartmentTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readUser = `-- name: ReadUser :one
SELECT u.id,
       u.username,
       u.email,
       u.role,
       u.enabled,
       u.last_login_at,
       e.id          as employee_id,
       e.last_name   as employee_last_name,
       e.first_name  as employee_first_name,
       e.middle_name as employee_middle_name,
       e.phone       as employee_phone,
       d.id          as department_id,
       d.title       as department_title
FROM users u
         LEFT JOIN employees e ON e.id = u.employee_id
         LEFT JOIN departments d on d.id = e.department_id
WHERE u.id = $1
`

type ReadUserRow struct {
	ID                 int64              `db:"id" json:"id"`
	Username           string             `db:"username" json:"username"`
	Email              string             `db:"email" json:"email"`
	Role               int32              `db:"role" json:"role"`
	Enabled            bool               `db:"enabled" json:"enabled"`
	LastLoginAt        pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
	EmployeeID         pgtype.Int8        `db:"employee_id" json:"employee_id"`
	EmployeeLastName   pgtype.Text        `db:"employee_last_name" json:"employee_last_name"`
	EmployeeFirstName  pgtype.Text        `db:"employee_first_name" json:"employee_first_name"`
	EmployeeMiddleName pgtype.Text        `db:"employee_middle_name" json:"employee_middle_name"`
	EmployeePhone      pgtype.Text        `db:"employee_phone" json:"employee_phone"`
	DepartmentID       pgtype.Int8        `db:"department_id" json:"department_id"`
	DepartmentTitle    pgtype.Text        `db:"department_title" json:"department_title"`
}

func (q *Queries) ReadUser(ctx context.Context, id int64) (*ReadUserRow, error) {
	row := q.db.QueryRow(ctx, readUser, id)
	var i ReadUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.Enabled,
		&i.LastLoginAt,
		&i.EmployeeID,
		&i.EmployeeLastName,
		&i.EmployeeFirstName,
		&i.EmployeeMiddleName,
		&i.EmployeePhone,
		&i.DepartmentID,
		&i.DepartmentTitle,
	)
	return &i, err
}

const setEnabledUser = `-- name: SetEnabledUser :execresult
UPDATE users
SET enabled = $1
WHERE id = $2
`

type SetEnabledUserParams struct {
	Enabled bool  `db:"enabled" json:"enabled"`
	ID      int64 `db:"id" json:"id"`
}

func (q *Queries) SetEnabledUser(ctx context.Context, arg *SetEnabledUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setEnabledUser, arg.Enabled, arg.ID)
}

const setLastLoginAtUser = `-- name: SetLastLoginAtUser :execresult
UPDATE users
SET last_login_at = now()
WHERE id = $1
`

func (q *Queries) SetLastLoginAtUser(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setLastLoginAtUser, id)
}

const setPasswordHashUser = `-- name: SetPasswordHashUser :execresult
UPDATE users
SET password_hash = $1
WHERE id = $2
`

type SetPasswordHashUserParams struct {
	PasswordHash string `db:"password_hash" json:"password_hash"`
	ID           int64  `db:"id" json:"id"`
}

func (q *Queries) SetPasswordHashUser(ctx context.Context, arg *SetPasswordHashUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setPasswordHashUser, arg.PasswordHash, arg.ID)
}

const updateUser = `-- name: UpdateUser :execresult
UPDATE users
SET username    = $1,
    email       = $2,
    role        = $3,
    employee_id = $4
WHERE id = $5
  AND (username != $1 OR email != $2 OR role != $3 OR employee_id IS DISTINCT FROM $4)
`

type UpdateUserParams struct {
	Username   string      `db:"username" json:"username"`
	Email      string      `db:"email" json:"email"`
	Role       int32       `db:"role" json:"role"`
	EmployeeID pgtype.Int8 `db:"employee_id" json:"employee_id"`
	ID         int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateUser,
		arg.Username,
		arg.Email,
		arg.Role,
		arg.EmployeeID,
		arg.ID,
	)
}
